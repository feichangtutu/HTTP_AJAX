## URI URL URN
>URI:统一资源标识符 <br/>
URL:统一资源路径地址 <br/>
URN:统一资源名称 <br/>
URI = URL + URN <br/>
一个完整的URL包含很多部分

####第一部分：传输协议
- 传输协议用来完成k客户端和服务器端的数据传输
- 客户端和服务端传输的内容总称`HTTP报文`，这些报文都是基于传输协议完成传输的，
客户端传送给服务器叫请求（Request），
服务器返回给客户端叫做响应（Response）
Request+Response两个阶段统称为一个HTTP事务（事务：一件完整的事情）
- HTTP事务：
    1. 当客户端向服务端发送请求，此时客户端和服务端会建立一个传输通道（连接通道）。
    传输协议就是基于这个通道把信息进行传输的
    2. 当服务端接收到请求信息，把内容返回给客户端后，传输通道自动销毁关闭
    
- 传输协议分类：
    1. HTTP:超文本传输协议，文本 视频 音频 图片 xml base64
    2. https：服务器端进行特殊处理，资金类网站
    3. 资源文本传输协议，一般用于客户端向服务器上传文件，或者从服务器下载文件
    传输的内容比较多
####HTTP报文
1. 起始行
+ 请求起始行
+ 响应起始行
2. 首部（头）
+ 请求头： 内置请求头，自定义请求头
+ 响应头： 内置响应头，自定义响应头
+ 通用头： 请求和响应都有的
3. 主体
+ 请求主体
+ 响应主体

>请求是客户端设置的信息,服务器端获取这些信息
>响应是服务器端设置的信息，客户端接收这些信息

####前端性能优化
- 减少前端请求次数
- 减少请求大小
- ....

###前端性能优化常用技巧
> *减少HTTP请求的次数*
> 页面中每发送一次HTTP请求，都需要完成请求+响应这个完整的HTTP事务,会消耗一些时间，
也可能会导致HTTP链接通道的阻塞，为了提高页面加载速度和运行的性能,应减少HTTP请求的次数，减小请求内容的大小（请求内容越大，请求时间越长）
1. css sprite:把一些小图合并在一张大图上,使用的时候通过背景图片定位，定位到某一个具体的小涂上
`css`
    
 ``` 
    .pubBg{
        background:url('./images/sprite.png') no-repeat;
        background-size: x y;//和原图大小保持一致
     }
     .box{
        background-postion: x y;
     }
```
`html`
```angular2html
    <div class="pubBg">
        <div class="box"></div>
    </div>
```
2. 真实项目中b把css js进行合并压缩，在移动端开发的时候，
如果css或者js文件不是很多，可以采取内嵌式，减少HTTP请求的次数，加快页面加载速度
    - css合并成一个，js合并成一个
    - 通过一些工具（webpack）把合并后的css或者js压缩成xxx.min.js,减少文件大小
    - 服务器端开启资源文件的GZIP压缩
  >通过一些自动化工具完成css js的合并压缩，或者less转css,es6转es5等操作，把这种自动化构建模式，称之为前端工程化开发
3. 采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而是用默认图占位，当页面加载完成后，
再根据相关的条件依次加载真实图片 （减少页面首次加载的HTTP请求次数）
   > 真实项目中，开始图片都不加载，页面首次加载完成，先把第一屏中可以看见的图片进行加载，随着页面滚动，再把下面区域中
   能够呈现出来的图片进行加载
   > 根据图片懒加载技术，我们还可以扩充出`数据的懒加载`
   > 1) 开始加载页面的时候，w我们只把首屏或者前两屏的数据从服务端请求过来，
   （有些网站首屏数据是后端渲染好，整体返回给客户端呈现的）
   > 2) 当页面进行下拉，滚动到哪个区域，再把这个区域需要的数据进行请求，（请求回来做数据绑定或数据延迟加载等）
   > 3) 分页展示技术采用的也是数据的懒加载实现的:如果我们请求的数据很多，最好分批请求，开始只请求第一页的数据，当用户点击第二页
   （微博是下拉到一定距离后，再请求第二页数据）的时候请求第二页数据……
4. 对于不经常更新的数据，最好采用浏览器的304缓存做处理 (主要由服务器端处理)
    1. 第一次请求css和js下来，浏览器会把请求的内容缓存下来，如果做了304处理，
    用户再次请求css和js，直接从缓存中读取，不需要再去服务器获取了，（减少http请求次数）
    2. 当用户强制刷新页面，或者缓存的文件发生了变动，都会重新从服务器拉取
    3. 对于客户端来讲，可以基于localStorage来做一些本地存储，例如第一次请求的数据或者不经常更新的css和js，我们都可以把内容储存到本地，
    下一次页面加载从本地获取即可，可以设定期限或者标识，控制从某个阶段重新从服务器获取
    
  
15. 如果页面出现了AUDIO 或者VEDIO标签，最好设置`preload=none:页面加载的时候音视频不进行加载，当播放的时候再开始加载`
   （减少页面首次加载时HTTP请求次数）
   > preload=auto:页面首次加载时加载音视频文件
   > preload=metadata: 页面首次加载时z只把音视频资源的头部信息进行加载
   
   
20. 在客户端和服务端进行数据传输的时候，尽量采取JSON格式
*优势*
+ JSON格式数据，n能清晰的展示数据结构，也方便获取和操作
+ 相对于以前的xml格式传输，JSON格式的数据更加轻量级
+ 客户端 服务端都支持JSON格式的数据处理,处理更方便
+ 真实项目中b并不是所有的数据都要基于JSON；
 特殊需求，如文件流的传输或者文档传输，无法用JSON
 
###编写代码时候的一些优化技巧
>除了减少HTTP请求，编写代码的时候也可以进行一些优化让页面提升性能（有些不好的代码会导致页面性能消耗太大，例如：内存泄漏）
1. 在编写js代码的时候,尽量减少对DOM的操作（VUE和REACT框架在这方面处理的不错）
>JS操作DOM非常耗性能，弊端：
> 1) DOM存在映射机制（JS中的DOM元素和页面中的DOM结构是存在映射机制的，一改则都改）
这种映射机制是浏览器按照W3C标准完成对JS的构建和DOM的构建（其实是构建了一个监听机制），
操作DOM要同时修改两个地方，相对于其他的js编程来说是耗性能的
> 2) 页面中DOM结构改变会触发浏览器的回流（浏览器会把DOM结构重新进行计算，这个操作是很耗性能都的）
和重绘（把一个元素的样式重新渲染）
2. 在编写代码的时候，更多的使用异步编程
> 同步编程会导致：上面任务完不成，下面任务也做不了，我们开发的时候可以把某一个区域模块设置为异步编程，
这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面的模块阻塞影响
> 尤其是AJAX数据请求，我们一般都是用异步编程，最好基于Promise设计模式进行管理（项目中常使用fetch, vue axios等插件进行ajax处理，
因为这些插件就是基于promise设计模式对ajax进行的封装处理）
3. 避免一次性循环过多数据，循环为同步操作；避免while导致死循环
4. css选择器优化
    1) 尽量减少标签选择器
    2) 尽可能少使用ID选择器，多使用样式类选择器，通用性强
    3) 减少使用选择器前面的前缀（less sass会有？）例如：`.header .nav .left a{}`
    选择器的查找为*从右向左*查找， 可以通过起名字做优化`.header-nav-left a`
5. 避免使用css表达式
    ```css
    /*css表达式*/
    .box{
       background-color: expression((new Date()).getHours()%2?'red':'blue');
     }
    ```
6. 减少页面中的冗余代码，尽可能提高方法的重复使用率，"低耦合高内聚"
7. css最好放在head中，js放在body尾部，让页面加载的时候，先加载css,再加载js(先呈现页面，再给用户提供操作)
8. JS中避免使用eval
    1. 性能消耗大
    2. 代码压缩后，容易出现代码错乱问题
9. JS中尽量减少闭包的使用
    1. 闭包会形成一个不销毁的栈内存，过多的栈内存累积会消耗性能
    2. 容易导致内存泄漏
    3. 闭包也有自己的优势：保存和保护，只能尽量减少使用
10. 在做DOM绑定的时候，尽量避免一个个的事件绑定，而采用x性能更高的事件委托来实现
    >事件委托，又叫事件代理
    >把事件绑定给外层容器，当里面的h后代元素相关行为被触发，外层容器绑定的方法也会被执行触发，（冒泡传播机制）
    通过判断事件源是谁，做不同的操作即可
    
    
###关于页面的seo优化
1. 页面中杜绝出现死链接（404页面），而且对于用户输入一个错误页面，我们要引导到404提示页面中
    